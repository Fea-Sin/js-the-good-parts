

## 正则表达式

JavaScript的许多特性都借鉴自其他语言。语法借鉴自Java，函数借鉴自Scheme，原型继承借鉴自Self。
而JavaScript的正则表达式特性则借鉴自Perl。

Scheme是一种多范型的编程语言，它是两种lisp主要的方言之一。而lisp是由约翰·麦卡锡在1960年左右创立
的一种基于演算的函数式编程语言。
Self语言，是一种基于原型的面向对象程序设计语言，于1986年由施乐帕洛阿尔托研究中心的David Ungar和
Randy Smith给出了最初的设计。

正则表达式是一门简单语言的语法规范。它应用在一些方法中，对字符串中的信息实现查找、替换和提取操作。
可处理正则表达式的方法有 regexp.exec、regexp.test、string.match、string.replace、string.search
和string.split。通常来说，在JavaScript中正则表达式相较于等效的字符串处理有着显著的性能优势。

正则表达式起源于对形式语言（formal language）的数学研究。Ken Thompson基于Stephen Kleene对type-3语言
的理论研究出了一个切实可用的模式匹配器，它能够被嵌入到编程语言和像文本编辑器这样的工具中。

在JavaScript中，正则表达式的语法是对Perl版本的改进和发展，它非常接近于贝尔实验室（Bell Labs）最初提出的构想。
正则表达式的书写规则出奇的复杂，在某些位置上的字符串可能解析为运算符，而仅在位置上稍微不同的相同字符串却可能被
当做字面量。比不易书写更糟糕的是，这使得正则表达式不仅难以阅读，而且修改时充满危险。要想正确地阅读它们，就必须
对正则表达式的整个复杂性有相当透彻的理解。为了缓解这个问题，我对它的规则进行了些许简化。这里所展示的正则表达式
可能稍微有些不简洁，但使用它们的时候不会那么容易出错。这是值得的，因为维护和调试正则表达式可能非常困难。

现在的正则表达式的规则并不总是严格的，但它们非常有用。正则表达式趋向于极致的简洁，甚至不惜容忍含义的模糊。
在最简单的形式下，它们是易于使用的，但可能很快就会变得让人费解。JavaScript的正则表达式难以分段阅读，因为它们
不支持注释和空白，正则表达式的所有部分都被紧密排列在一起，使得它们几乎无法被辨认。当它们在安全应用中进行
扫描和验证时，这点就需要特别留意。如果你不能阅读和理解一个正则表达式，你如何能确保它对所有的输入都能正确地工作呢？
然而，尽管有些明显的缺点，但正则表达式还是被广泛地应用着。

### 一个例子

这里有一个例子。它是一个用来匹配URL的正则表达式。在JavaScript中，正则表达式必须写在一行中。空白需要特别注意。
```
var parse_url = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;

var url = "http://www.ora.com:80/googparts?q#fragment";
```
让我们调用parse_url的exec方法。如果能成功匹配我们传递给它的字符串，它会返回一个数组，该数组包含了
从这个url中提取出来的片段
```
var url = "http://www.ora.com:80/goodparts?q#fragment";
var result = parse_url.exec(url);

var names = ['url', 'scheme', 'slash', 'host', 'port', 'path', 'query', 'hash'];
var blanks = '    ';
var i;
for (i = 0; i < names.length; i++) {
  document.writeln(names[i] + ':' +
    blanks.substring(names[i].length), result[i])
}
```
这段代码产生的结果如下
```
url:    http://www.ora.com:80/goodparts?q#fragment
scheme: http
slash:  //
host:   www.ora.com
path:   goodparts
query:  q
hash:   fragment
```

正则表达式不能像函数那样被分解成小片段，让我们分解parse_url个各个部分，看看它是如何工作的
`^`字符表示此字符串的开始。它是一个锚，指引exec跳过那些不像URL的前缀，只匹配那些从开头就像
URL一样的字符串。
`(?:([A-Za-z]+):)?`
这个因子匹配一个协议名，但仅当它后面跟随一个`:`的时候才匹配
`(?: ...)`表示一个非捕获型分组（noncapturing group）。后缀`?`表示这个分组是可选的，它表示
重复0次或1次。
`(...)`表示一个捕获型分组（capturing group）。一个捕获型分组会复制它所匹配的文本，并把其放到result数组里。
每个捕获型分组会被指定一个编号。第一个捕获型分组的编号是1，所以该分组所匹配的文本副本会出现在`result[1]`中。

`[...]`表示一个字符类。A-Za-z这个字符类包含26个大写字母和26个小写字母。连字符(-)表示范围从A到Z。
后缀`+`表示这个字符类会被匹配一次或多次。
这个组后面跟着字符`:`，它会按字面进行匹配。

`(\/{0,3})`这个因子是捕获型分组2。`\/`表示应该匹配`/`。他用`\`反斜杠来进行转义，这样它就不会被错误
地解释为这个正则表达式的结束符。后缀`{0,3}`表示`/`会被匹配0次或者1～3次。

`([0-9.\-A-Za-z]+)`这个因子是捕获型分组3。它会匹配一个主机名，由一个或多个数字、字母，以及`.`或`-`
字符组成。

`(?::(\d+))?`这个因子匹配端口号，它是由一个前缀`:`加上一个或多个数字而组成的序列。`\d`表示一个数字字符。
一个或多个数字组成的数字串会被捕获型分组4捕获。

`(?:\/([^?#]*))?`这也是一个可选分组。该分组以一个`/`开始。之后的字符类`[^?#]`以一个`^`开始，它表示
这个类包含除`?`和`#`之外的所有字符。`*`表示这个字符类会被匹配0次或多次。

注意我在这里的处理是不严谨的。这个类匹配除 ？和 # 之外的所有字符，其中包括了行结束符、控制字符，以及其他
大量不应在此匹配的字符。大多数情况下，它会按照我们的预期去做，但某些恶意文本可能会有渗漏进来的风险。不严谨
的正则表达式是一个常见的安全漏洞发源地。写不严谨的正则表达式比写严谨的正则表达式要容易得多。

`(?:\?([^#]*))?`这个因子，我们以一个？开始的可选分组。它包含分组6，这个分组包含0个或多个非#字符。

`(?:#(.*))?`我们的最后一个可选分组以#开始的。`.`会匹配除行结束符以外的所有字符。

`$`表示这个字符串的结束。它保证在这个URL的尾部没有其他更多内容了。

parse_url的正则表达式还可以编写得更复杂，但我不建议这样做。短小精悍的正则表达式是最好的。
唯有如此，我们才有信心让它们正确地工作并在需要时能顺利地修改它们。

JavaScript的语言处理程序之间兼容性非常高。这门语言中最没有移植性的部分就是对正则表达式的实现。
结构复杂或令人费解的正则表达式很有可能导致移植性问题。在执行某些匹配时，嵌套的正则表达式也能导致
极恶劣的性能问题。因此简单是最好的策略。

让我们来看另一个例子，一个匹配数字的正则表达式。数字可能由一个整数部分加上一个可选的负号、一个可选
的小数部分和一个可选的指数部分组成
```
var parse_number = /^-?\d+(?:\.\d*)?(?:e[+\-]?\d+)?$/i;
var test = function(num) {
  document.writeln(parse_number.test(num));
}

test('1')       // true
test('number')  // false
test('98.6')    // true
test('132.21.86.100')  //false
test('123.45E-76')     // true
test('123.45D-67')     // false
```
parse_number成功地检验出这些字符串中，哪些符合我们的规范，哪些不符合，但对那些不符合的字符串，
它并没有告诉我们测试失败的缘由和位置。

我们又用^和$来框定这个正则表达式。它指引这个正则表达式对文本中的所有字符都进行匹配。如果我们省略
了这些标识，那么只要一个字符串包含一个数字，这个正则表达式就会进行匹配。但有了这些标识，只有当一个
字符串的内容仅为一个数字时，它才会告诉我们。如果我们仅包含^，它将匹配一个数字开头的字符串。如果
我们仅包含$，则匹配以一个数字结尾的字符串。

i标识表示匹配字母时忽略大小写。在我们的模式中唯一可能出现的字母是e。我们希望既能识别e，也能匹配E。
我们可以把e因子写成`[eE]`或`(?:E|e)`，但不必这么麻烦，因为我们使用了标识符i。

负号后面的？后缀表示这负号是可选的。
`\d+` \d的含义和`[0-9]`一样。它匹配一个数字。
`(?:\.\d*)?` `(?:...)?`表示一个可选的非捕获型分组。通常用非捕获型分组来替代少量不优美的捕获型分组是
很好的方法，因为捕获会有性能上的损失。

### 结构

有两个方法来创建一个RegExp对象。在以前的例子中我们可以看到，优先考虑的方法是使用正则表达式字面量。

正则表达式字面量被包围在一对斜杠中。这有点令人难以捉摸，因为斜杠也被用做除法运算符和注释符。

RegExp能设置3个标识。它们分别由字母g、i和m来表示，我把它们列在表中。这些标识被直接添加在RegExp字面量
的末尾。
```
// 构造一个匹配JavaScript字符串的正则表达式对象
var my_regexp = /"(?:\\.|[^\\\"])*"/g;
```

| 标识 | 含义 |
|----|----|
| g | 全局的（匹配多次，不同的方法对g标识的处理各不相同） |
| i | 大小写不敏感 |
| m | 多行（^和$能匹配行结束符）|

创建一个正则表达式的另一个方法是使用RegExp构造器。这个构造器接收一个字符串，并把它编译为一个RegExp对象。
创建这个字符串时请多加小心，因为反斜杠在正则表达式和在字符串字面量中有一些不同的含义。通常需要
双写反斜杠，以及对引号进行转义。

```
// 创建一个匹配JavaScript字符串的正则表达式
var my_regexp = new RegExp("\"(?:\\\\.|[^\\\\\\\"])*\"", 'g');
```
第2个参数是一个指定标识的字符串。RegExp构造器适用于必须在运行时动态生成正则表达式的情形。

用正则表达式字面量创建RegExp对象共享同一个单例
```
function make_a_matcher() {
  return /a/gi
}
var x = make_a_matcher();
var y = make_a_matcher();

// x和y是相同的对象
x.lastIndex = 10;
document.writeln(y.lastIndex);
```

### 元素

让我们进一步看看那些构成正则表达式的元素。

一个正则表达式分支包含一个或多个正则表达式序列。这些序列被｜(竖线)字符分隔。如果这些序列中的任何
一项符合匹配条件，那么这个选择就被匹配。它尝试按顺序依次匹配这些序列项。
```
"into".match(/in|int/)
```
会在into中匹配in，但不会匹配int，因为in已被成功匹配了。

### 正则表达式序列

一个正则表达式序列包含一个或多个正则表达式因子。每个因子能选择是否跟随一个量词，这个量词决定着这个因子
被允许出现的次数。如果没有指定这个量词，那么该因子只会被匹配一次。

### 正则表达式因子

一个正则表达式因子可以是一个字符、一个由圆括号包围的组、一个字符类，或者是一个转义序列。除了控制字符和
特殊字符以外，所有的字符都会被按照字面处理。
```
\ / [] () {} ? + * | . ^ $
```
如果你希望上面列出的字符按字面去匹配，那么必须要用一个`\`前缀来进行转义。你如果拿不准的话，可以给任何特殊
字符都添加一个`\`前缀来使其字面化。注意前缀`\`不能使字母或数字字面化。

一个未被转义的`.`会匹配除行结束符以外的任何字符。

当lastIndex属性值为0时，一个未转义的`^`会匹配文本的开始。当指定了m标识时，它也能匹配行结束符。

一个未被转义的$将匹配文本的结束。当指定了m标识时，它也能匹配行结束符。

### 正则表达式转义

反斜杠字符在正则表达式因子中与其在字符串中一样均表示转义，但是在正则表达式因子中，它稍有一点不同。

像在字符串中一样，`\f`是换页符，`\n`是换行符，`\r`是回车符，`\`是制表符，并且`\u`允许指定一个
Unicode字符来表示一个十六进制的常量。但在正则表达式因子中，`\b`不是退格（backspace）符。

`\d`等同于`[0-9]`，它匹配一个数字。`\D`则表示与其相反的`^0-9`。

`\s`等同于`[\f\n\r\t\u000B\u0020\u00A0\u2028\u2029]`。这是Unicode空白（whitespace）符
的一个不完全子集。`\S`则表示与其相反的`[^\f\n\r\t\u000B\u0020\u00A0\u2028\u2029]`。

`\w`等同于`[0-9A-Z_a-z]`。`\W`则表示与其相反的`[^0-9A-Z_a-z]`。`\W`本意是希望表示出现在
话语中的字符。遗憾的是，它所定义的类实际上对任何真正的语言来说都不起作用。如果你需要匹配信件
一类的文本，你必须指定自己的类。

一个简单的字母类是`[A-Za-z\u00C0-\u1FFF\u2800-\uFFFD]`。它包含所有的Unicode字母，
但它也不包括成千上万非字母的字符。Unicode是巨大而复杂的。构建一个基本多语言面的精确字母类是有可能的，
但它将会变得庞大而低效。JavaScript的正则表达式对国际化的支持非常有限。

`\b`被指定为一个字边界（word-boundary）标识，它方便用于对文本的字符边界进行匹配。遗憾的是，它使用
`\w`去寻找字边界，所以它对多语言应用来说是完全无用的。这并不是一个好的特性。

`\1`是指向分组1所捕获的文本的一个引用，所以它能被再次匹配。例如，你能用下面的正则表达式来搜索文本中的
重复的单词
```
var doubled_words = /([A-Za-z\u00C0-\u1FFF\u2800-\uFFFD]+)\s+\1/gi;
```

doubled_words会寻找重复的单词（包含一个或多个字母的字符串），该单词的后面跟着一个或多个空白，
然后再跟着它相同的单词。

`\2`是指向分组2的引用，`\3`是指向分组3的引用，以此类推。

### 正则表达式分组

分组公有4种

#### 捕获型

一个捕获型分组是一个被包围在圆括号中的正则表达式分支。任何匹配这个分组的字符都会被捕获。每个捕获型分组
都被指定了一个数字。在正则表达式第1个捕获（ 的是分组 1，第2个捕获（ 的是分组2。

#### 非捕获型

非捕获型分组有一个`(?:`前缀。非捕获型分组仅做简单的匹配，并不会捕获所有匹配的文本。这会带来微弱的性能
优势。非捕获型分组不会干扰捕获型分组的编号。

#### 向前正向匹配（Positive lookedhead）

向前正向匹配分组有一个`(?=`前缀。它类似于非捕获型分组，但在这个组匹配后，文本会倒回到它开始的地方，
实际上并不匹配任何东西。这不是一个好的特性。

#### 向前负向匹配（Negative lookedhead）

向前负向匹配分组有一个`(?!`前缀。它类似于向前正向匹配分组，但只有当它匹配失败时才继续向前进行匹配。
这不是一个好的特性。

### 正则表达式字符集

正则表达式字符集是一种指定一组字符的便利方法。例如，如果想匹配一个元音字母，我们可以写做`(?:a|e|i|o|u)`，
但它可以被更方便地写成一个类`[aeiou]`。

类提供另外两个便利。第1个是能够指定字符范围。所以，一组32个ASCII的特殊字符字符组成的集合
```
! " # $ % & ' () * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~
```

如果`[`后的第一个字符是`^`，那么这个类会排除这些这些特殊字符。


### 正则表达式转义

字符类内部的转义规则和正则表达式因子的相比稍有不同。此处的`[\b]`是退格符。下面是
在字符类中需要被转义的特殊字符
```
- / [ \ ] ^
```

### 正则表达式量词

正则表达式因子可以用一个正则表达式量词后缀来决定这个因子应该被匹配的次数。包围在一对花括号中的
一个数字表示这个因子应该被匹配的次数。所以，`/www/`匹配的和`/w{3}/`一样，`{3,6}`会匹配
3、4、5或6次，`{3,}`会匹配3次或更多次。

`?`等同于`{0,1}`

`*`等同于`{0,}`

`+`等同于`{1,}`

如果只有一个量词，表示趋向于进行贪婪性匹配，即匹配尽可能多的副本直到达到上限。
如果这个量词附加一个后缀`?`，则表示趋向于进行非贪婪匹配，即只匹配必要的副本就好。
一般情况下最好坚持使用贪婪性匹配。
