

## 正则表达式

JavaScript的许多特性都借鉴自其他语言。语法借鉴自Java，函数借鉴自Scheme，原型继承借鉴自Self。
而JavaScript的正则表达式特性则借鉴自Perl。

Scheme是一种多范型的编程语言，它是两种lisp主要的方言之一。而lisp是由约翰·麦卡锡在1960年左右创立
的一种基于演算的函数式编程语言。
Self语言，是一种基于原型的面向对象程序设计语言，于1986年由施乐帕洛阿尔托研究中心的David Ungar和
Randy Smith给出了最初的设计。

正则表达式是一门简单语言的语法规范。它应用在一些方法中，对字符串中的信息实现查找、替换和提取操作。
可处理正则表达式的方法有 regexp.exec、regexp.test、string.match、string.replace、string.search
和string.split。通常来说，在JavaScript中正则表达式相较于等效的字符串处理有着显著的性能优势。

正则表达式起源于对形式语言（formal language）的数学研究。Ken Thompson基于Stephen Kleene对type-3语言
的理论研究出了一个切实可用的模式匹配器，它能够被嵌入到编程语言和像文本编辑器这样的工具中。

在JavaScript中，正则表达式的语法是对Perl版本的改进和发展，它非常接近于贝尔实验室（Bell Labs）最初提出的构想。
正则表达式的书写规则出奇的复杂，在某些位置上的字符串可能解析为运算符，而仅在位置上稍微不同的相同字符串却可能被
当做字面量。比不易书写更糟糕的是，这使得正则表达式不仅难以阅读，而且修改时充满危险。要想正确地阅读它们，就必须
对正则表达式的整个复杂性有相当透彻的理解。为了缓解这个问题，我对它的规则进行了些许简化。这里所展示的正则表达式
可能稍微有些不简洁，但使用它们的时候不会那么容易出错。这是值得的，因为维护和调试正则表达式可能非常困难。

现在的正则表达式的规则并不总是严格的，但它们非常有用。正则表达式趋向于极致的简洁，甚至不惜容忍含义的模糊。
在最简单的形式下，它们是易于使用的，但可能很快就会变得让人费解。JavaScript的正则表达式难以分段阅读，因为它们
不支持注释和空白，正则表达式的所有部分都被紧密排列在一起，使得它们几乎无法被辨认。当它们在安全应用中进行
扫描和验证时，这点就需要特别留意。如果你不能阅读和理解一个正则表达式，你如何能确保它对所有的输入都能正确地工作呢？
然而，尽管有些明显的缺点，但正则表达式还是被广泛地应用着。

### 一个例子

这里有一个例子。它是一个用来匹配URL的正则表达式。在JavaScript中，正则表达式必须写在一行中。空白需要特别注意。
```
var parse_url = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;

var url = "http://www.ora.com:80/googparts?q#fragment";
```
让我们调用parse_url的exec方法。如果能成功匹配我们传递给它的字符串，它会返回一个数组，该数组包含了
从这个url中提取出来的片段
```
var url = "http://www.ora.com:80/goodparts?q#fragment";
var result = parse_url.exec(url);

var names = ['url', 'scheme', 'slash', 'host', 'port', 'path', 'query', 'hash'];
var blanks = '    ';
var i;
for (i = 0; i < names.length; i++) {
  document.writeln(names[i] + ':' +
    blanks.substring(names[i].length), result[i])
}
```
这段代码产生的结果如下
```
url:    http://www.ora.com:80/goodparts?q#fragment
scheme: http
slash:  //
host:   www.ora.com
path:   goodparts
query:  q
hash:   fragment
```

正则表达式不能像函数那样被分解成小片段，让我们分解parse_url个各个部分，看看它是如何工作的
`^`字符表示此字符串的开始。它是一个锚，指引exec跳过那些不像URL的前缀，只匹配那些从开头就像
URL一样的字符串。
`(?:([A-Za-z]+):)?`
这个因子匹配一个协议名，但仅当它后面跟随一个`:`的时候才匹配
`(?: ...)`表示一个非捕获型分组（noncapturing group）。后缀`?`表示这个分组是可选的，它表示
重复0次或1次。
`(...)`表示一个捕获型分组（capturing group）。一个捕获型分组会复制它所匹配的文本，并把其放到result数组里。
每个捕获型分组会被指定一个编号。第一个捕获型分组的编号是1，所以该分组所匹配的文本副本会出现在`result[1]`中。

`[...]`表示一个字符类。A-Za-z这个字符类包含26个大写字母和26个小写字母。连字符(-)表示范围从A到Z。
后缀`+`表示这个字符类会被匹配一次或多次。
这个组后面跟着字符`:`，它会按字面进行匹配。

`(\/{0,3})`这个因子是捕获型分组2。`\/`表示应该匹配`/`。他用`\`反斜杠来进行转义，这样它就不会被错误
地解释为这个正则表达式的结束符。后缀`{0,3}`表示`/`会被匹配0次或者1～3次。

`([0-9.\-A-Za-z]+)`这个因子是捕获型分组3。它会匹配一个主机名，由一个或多个数字、字母，以及`.`或`-`
字符组成。

`(?::(\d+))?`这个因子匹配端口号，它是由一个前缀`:`加上一个或多个数字而组成的序列。`\d`表示一个数字字符。
一个或多个数字组成的数字串会被捕获型分组4捕获。

`(?:\/([^?#]*))?`这也是一个可选分组。该分组以一个`/`开始。之后的字符类`[^?#]`以一个`^`开始，它表示
这个类包含除`?`和`#`之外的所有字符。`*`表示这个字符类会被匹配0次或多次。

注意我在这里的处理是不严谨的。这个类匹配除 ？和 # 之外的所有字符，其中包括了行结束符、控制字符，以及其他
大量不应在此匹配的字符。大多数情况下，它会按照我们的预期去做，但某些恶意文本可能会有渗漏进来的风险。不严谨
的正则表达式是一个常见的安全漏洞发源地。写不严谨的正则表达式比写严谨的正则表达式要容易得多。

`(?:\?([^#]*))?`这个因子，我们以一个？开始的可选分组。它包含分组6，这个分组包含0个或多个非#字符。

`(?:#(.*))?`我们的最后一个可选分组以#开始的。`.`会匹配除行结束符以外的所有字符。

`$`表示这个字符串的结束。它保证在这个URL的尾部没有其他更多内容了。

parse_url的正则表达式还可以编写得更复杂，但我不建议这样做。短小精悍的正则表达式是最好的。
唯有如此，我们才有信心让它们正确地工作并在需要时能顺利地修改它们。

JavaScript的语言处理程序之间兼容性非常高。这门语言中最没有移植性的部分就是对正则表达式的实现。
结构复杂或令人费解的正则表达式很有可能导致移植性问题。在执行某些匹配时，嵌套的正则表达式也能导致
极恶劣的性能问题。因此简单是最好的策略。

让我们来看另一个例子，一个匹配数字的正则表达式。数字可能由一个整数部分加上一个可选的负号、一个可选
的小数部分和一个可选的指数部分组成
```
var parse_number = /^-?\d+(?:\.\d*)?(?:e[+\-]?\d+)?$/i;
var test = function(num) {
  document.writeln(parse_number.test(num));
}

test('1')       // true
test('number')  // false
test('98.6')    // true
test('132.21.86.100')  //false
test('123.45E-76')     // true
test('123.45D-67')     // false
```
parse_number成功地检验出这些字符串中，哪些符合我们的规范，哪些不符合，但对那些不符合的字符串，
它并没有告诉我们测试失败的缘由和位置。

我们又用^和$来框定这个正则表达式。它指引这个正则表达式对文本中的所有字符都进行匹配。如果我们省略
了这些标识，那么只要一个字符串包含一个数字，这个正则表达式就会进行匹配。但有了这些标识，只有当一个
字符串的内容仅为一个数字时，它才会告诉我们。如果我们仅包含^，它将匹配一个数字开头的字符串。如果
我们仅包含$，则匹配以一个数字结尾的字符串。

i标识表示匹配字母时忽略大小写。在我们的模式中唯一可能出现的字母是e。我们希望既能识别e，也能匹配E。
我们可以把e因子写成`[eE]`或`(?:E|e)`，但不必这么麻烦，因为我们使用了标识符i。

负号后面的？后缀表示这负号是可选的。
`\d+` \d的含义和`[0-9]`一样。它匹配一个数字。
`(?:\.\d*)?` `(?:...)?`表示一个可选的非捕获型分组。通常用非捕获型分组来替代少量不优美的捕获型分组是
很好的方法，因为捕获会有性能上的损失。

### 结构

有两个方法来创建一个RegExp对象。在以前的例子中我们可以看到，优先考虑的方法是使用正则表达式字面量。

正则表达式字面量被包围在一对斜杠中。这有点令人难以捉摸，因为斜杠也被用做除法运算符和注释符。

RegExp能设置3个标识。它们分别由字母g、i和m来表示，我把它们列在表中。这些标识被直接添加在RegExp字面量
的末尾。
```
// 构造一个匹配JavaScript字符串的正则表达式对象
var my_regexp = /"(?:\\.|[^\\\"])*"/g;
```

| 标识 | 含义 |
|----|----|
| g | 全局的（匹配多次，不同的方法对g标识的处理各不相同） |
| i | 大小写不敏感 |
| m | 多行（^和$能匹配行结束符）|

创建一个正则表达式的另一个方法是使用RegExp构造器。这个构造器接收一个字符串，并把它编译为一个RegExp对象。
创建这个字符串时请多加小心，因为反斜杠在正则表达式和在字符串字面量中有一些不同的含义。通常需要
双写反斜杠，以及对引号进行转义。

```
// 创建一个匹配JavaScript字符串的正则表达式
var my_regexp = new RegExp("\"(?:\\\\.|[^\\\\\\\"])*\"", 'g');
```
第2个参数是一个指定标识的字符串。RegExp构造器适用于必须在运行时动态生成正则表达式的情形。

用正则表达式字面量创建RegExp对象共享同一个单例
```
function make_a_matcher() {
  return /a/gi
}
var x = make_a_matcher();
var y = make_a_matcher();

// x和y是相同的对象
x.lastIndex = 10;
document.writeln(y.lastIndex);
```

### 元素


